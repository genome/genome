#!/usr/bin/env genome-perl

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
    $ENV{UR_COMMAND_DUMP_STATUS_MESSAGES} = 1;
}

use strict;
use warnings;

use File::Spec;
use Test::Exception;
use Test::More;

use above 'Genome';

use Genome::Utility::Test;

use_ok('Genome::InstrumentData::Solexa') or die;

my $instrument_data = Genome::InstrumentData::Solexa->create(
    id => -7777,
    flow_cell_id => '12345',
    lane => '1',
    median_insert_size => '22',
    run_name => '110101_TEST',
    subset_name => 4,
    run_type => 'Paired',
    clusters => 300,
    fwd_clusters => 300,
    rev_clusters => 300,
    fwd_read_length => 50,
    rev_read_length => 50,
    bam_path => Genome::Config::get('test_inputs') . '/Genome-InstrumentData-AlignmentResult-Bwa/input.bam',
);
ok($instrument_data, 'create inst data');

# Read/base counts
is($instrument_data->is_paired_end, 1, 'instrument data is paired end');
is($instrument_data->calculate_alignment_estimated_kb_usage, 117,'117kB disk needed for paired end instrument data');
is($instrument_data->total_bases_read('forward-only'), 15000, 'forward only total_bases_read on paired end instrument data');
is($instrument_data->total_bases_read('reverse-only'), 15000, 'reverse only total_bases_read on paired end instrument data');
is(
    $instrument_data->total_bases_read('forward-only') + $instrument_data->total_bases_read('reverse-only'),
    $instrument_data->total_bases_read,
    'forward and reverse pairs add up to total bases',
);
is($instrument_data->read_count, 600, 'read count');

# Trimmer conversion to SX
#  class for testing
class Genome::Model::Tools::Sx::Trim::Foo {
    has => [
        num => { is => 'Number' },
        words => { is => 'Text' },
        bool => { is => 'Boolean' },
    ],
};
#  new style - fails
ok(
    !eval{$instrument_data->_convert_trimmer_to_sx_commands()},
    'Failed to convert trimmer to sx cmd w/ trimmer version!',
);
ok(
    !eval{$instrument_data->_convert_trimmer_to_sx_commands(unknown_params => 1)},
    'Failed to convert trimmer to sx cmd w/ trimmer version!',
);
ok(
    !eval{$instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'gmt sx trim foo', trimmer_version => 'bar',)},
    'Failed to convert trimmer to sx cmd w/ trimmer version!',
);
ok(
    !eval{$instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'gmt sx trim foo', trimmer_params => 'bar',)},
    'Failed to convert trimmer to sx cmd w/ trimmer params!',
);
#  new style - success
#   one cmd
is_deeply(
    [$instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'gmt sx trim foo')],
    ['trim foo'],
    '"test" is an SX trimmer and the command parts are ok!',
);
#   multi cmd
my @sx_cmd_parts = (
    'trim foo --num 20',
    'trim foo --words hi',
    'trim foo --bool --num 40',
);
is_deeply(
    [$instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'gmt sx '.join('  |   ', @sx_cmd_parts))], 
    \@sx_cmd_parts,
    '"gmt sx '.join(' | ', @sx_cmd_parts).'"  an SX trimmer and the command parts are ok!',
);

#  old style - success
is_deeply(
    [$instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'foo')],
    ['trim foo'],
    'Old style SX trimmer "foo" commands are ok!',
);
is_deeply( # w/ params as --
    [$instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'foo', trimmer_params => '--num 20 --words "hello world!" --bool 1')],
    ['trim foo --num 20 --words \'hello world!\' --bool'],
    'Old style SX trimmer "foo" w/ params \'-num 20 --words "hello world!" -bool 1\' commands are ok!',
);
is_deeply( # w/ params as -- tests boolean false
    [$instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'foo', trimmer_params => "--num 20 --words 'hello world!' --bool 0")],
    ["trim foo --num 20 --words 'hello world!'"],
    'Old style SX trimmer "foo" w/ params \'--num 20 --words "hello world!" [boolean is false] commands are ok!',
);
is_deeply( # w/ params as name => val
    [$instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'foo', trimmer_params => 'num => 20, words => "hello world", bool => 1')],
    ["trim foo --num 20 --words 'hello world' --bool"],
    'Old style SX trimmer "foo" w/ params [=>] "-num 20 --words hello" -bool 1" commands are ok!',
);
is_deeply( # w/ params as -- tests boolean false
    [$instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'foo', trimmer_params => 'num => 20, words => "hello world", bool => 0,')],
    ["trim foo --num 20 --words 'hello world'"],
    'Old style SX trimmer "foo" w/ params [=> and boolean is false] "-num 20 --words "hello world"" commands are ok!',
);
is_deeply( # 'no' property
    [$instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'gmt sx trim flexbar --adapter CTTTGTGTTTGA --adapter-trim-end LEFT --nono-length-dist --threads 12 --adapter-min-overlap 7 --max-uncalled 150 --min-readlength 25')],
    ['trim flexbar --adapter CTTTGTGTTTGA --adapter-trim-end LEFT --nono-length-dist --threads 12 --adapter-min-overlap 7 --max-uncalled 150 --min-readlength 25'],
    '"flexbar" w/ params w/ "no" property is an SX trimmer and the command parts are ok!',
);
is_deeply( # new SX style, but in trimmer params
    [$instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'flexbar', trimmer_params => '--adapter "CTTTGT  GTTTGA" --adapter-trim-end LEFT --nono-length-dist --threads 12 --adapter-min-overlap 7 --max-uncalled 150 --min-readlength 25')],
    ["trim flexbar --adapter 'CTTTGT  GTTTGA' --adapter-trim-end LEFT --nono-length-dist --threads 12 --adapter-min-overlap 7 --max-uncalled 150 --min-readlength 25"],
    '"flexbar" new style, but in trimmer_params command parts are ok!',
);

#  old style - fails
throws_ok(
    sub{ $instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'foo', trimmer_params => '--nm 20'); },
    qr/Failed to get property 'nm' from sx class/,
    'Old style SX trimmer "foo" w/ INVALID params "-nm 20" fails!',
);

    $instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'foo', trimmer_params => 'num'); 
throws_ok(
    sub{ $instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'foo', trimmer_params => 'num'); },
    qr//,
    'Old style SX trimmer "foo" w/ INVALID params "num" fails!',
);


my $adapter_file = File::Spec->join(Genome::Utility::Test->data_dir('Genome::InstrumentData::Solexa'), qw(adaptors ADAPTORS.fa));
is_deeply( # this has a special case that needs to be supported using the real far class
    [$instrument_data->_convert_trimmer_to_sx_commands(
        trimmer_name => 'far',
        trimmer_params => '--adapters ' . $adapter_file . ' --trim-end right --min-readlength 17 --nr-threads 4 --algorithm needlemanQuality --adaptive-overlap yes --format blah', 
        trimmer_version => '2.17',
    )],
    ["trim far --adapters $adapter_file --trim-end right --min-readlength 17 --nr-threads 4 --algorithm needlemanQuality --adaptive-overlap yes --version 2.17"],
    'converted trimmer FAR params: "--fixed-pre-trim 150 --adapters ' . $adapter_file . ' --trim-end right --min-readlength 17 --nr-threads 4 --algorithm needlemanQuality --adaptive-overlap yes --format blah"',
);

# Not SX - return undef
ok(!eval{$instrument_data->_convert_trimmer_to_sx_commands(trimmer_name => 'far-gone')}, '"far-gone" is not an SX trimmer! '.$@);

# Dump/Trim
my $tmpdir = File::Temp::tempdir(CLEANUP => 1);
# straight dump
my @fastq_pathnames = $instrument_data->dump_sanger_fastq_files(directory => $tmpdir);
is(@fastq_pathnames, 2, 'dump sanger fastq files');
# dump trimmed w/o trimming
my @trimmed_fastq_pathnames = $instrument_data->dump_trimmed_fastq_files(directory => $tmpdir);
is_deeply(\@fastq_pathnames, \@trimmed_fastq_pathnames, 'dump trimmed fastq files w/o trimming - matches untrimmed path names');
# dump sx 'new'
@trimmed_fastq_pathnames = $instrument_data->dump_trimmed_fastq_files(directory => $tmpdir, trimmer_name => 'gmt sx trim remove --length 10');
is(@trimmed_fastq_pathnames, 2, 'dump "new" sx trimmed sanger fastq files');
is(Genome::Sys->md5sum($trimmed_fastq_pathnames[0]), 'd9e3d9ee9b8c46b29b7d366affaae25d', 'trimmed fastq file 1 matches');
is(Genome::Sys->md5sum($trimmed_fastq_pathnames[1]), 'd46046c148dcf8437d023904c8d83679', 'trimmed fastq file 2 matches');
#print "$tmpdir\n"; <STDIN>;
for ( @trimmed_fastq_pathnames ) { unlink; }

# dump sx 'old'
@trimmed_fastq_pathnames = $instrument_data->dump_trimmed_fastq_files(directory => $tmpdir, trimmer_name => 'remove', trimmer_params => '--length 10');
is(@trimmed_fastq_pathnames, 2, 'dump "old" sx trimmed sanger fastq files');
is(Genome::Sys->md5sum($trimmed_fastq_pathnames[0]), 'd9e3d9ee9b8c46b29b7d366affaae25d', 'trimmed fastq file 1 matches');
is(Genome::Sys->md5sum($trimmed_fastq_pathnames[1]), 'd46046c148dcf8437d023904c8d83679', 'trimmed fastq file 2 matches');
#print "$tmpdir\n"; <STDIN>;
for ( @trimmed_fastq_pathnames ) { unlink; }

done_testing();
