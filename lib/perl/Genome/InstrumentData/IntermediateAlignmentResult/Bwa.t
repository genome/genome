use strict;
use warnings;

use File::Path;
use Test::More;
use Sys::Hostname;
use File::Basename;

use above 'Genome';
use Genome::Test::Factory::SoftwareResult::User;

BEGIN {
    if (`uname -a` =~ /x86_64/) {
        plan tests => 27;
    } else {
        plan skip_all => 'Must run on a 64 bit machine';
    }
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
    $ENV{UR_DBI_NO_COMMIT} = 1;
}

my $result_class = 'Genome::InstrumentData::IntermediateAlignmentResult::Bwa';
use_ok($result_class);

my $aligner_name = 'bwa';
my $aligner_version = Genome::Model::Tools::Bwa->default_bwa_version;
my $aligner_label   = $aligner_name.$aligner_version;
$aligner_label =~ s/\./\_/g;

my $samtools_version = 'r599';

# Gather test data
my $reference_model = Genome::Model::ImportedReferenceSequence->get(name => 'TEST-human');
ok($reference_model, "got reference model");

my $reference_build = $reference_model->build_by_version('1');
ok($reference_build, "got reference build");

my $result_users = Genome::Test::Factory::SoftwareResult::User->setup_user_hash(
    reference_sequence_build => $reference_build,
);

my $aligner_index = Genome::Model::Build::ReferenceSequence::AlignerIndex->get_or_create(reference_build=>$reference_build, aligner_version=>$aligner_version, aligner_name=>$aligner_name, aligner_params=>'',users => $result_users);
ok($aligner_index, "prepared temporary reference index");

my $instrument_data = generate_fake_instrument_data();
my $parent_result = generate_fake_alignment_result($instrument_data);
my $input_file = $instrument_data->bam_path();
my $input_base = basename($input_file);

# Do testing
my %params = (
    instrument_data_id => $instrument_data->id,
    aligner_name => $aligner_name,
    aligner_version => $aligner_version,
    aligner_index => $aligner_index,
    input_file => $input_file,
    input_pass => 1,
    samtools_version => $samtools_version,
);

my @result_ids;

######################################################################
# Make first object
my $result = $result_class->create(%params);
ok($result, "created result (1st end)");
$result->add_user(label => 'uses', user => $parent_result); #normally the outer alignment would do this upon getting back the intermediate result
push(@result_ids, $result->id);

ok($result->users, "found parent in software result users");
my $parent_in_users = grep {$_->user_id == $parent_result->id and $_->user_class_name eq $parent_result->class} $result->users;
ok($parent_in_users, "found parent in list of users");

my $dir = $result->output_dir;
ok(-s $result->sai_file, "sai file exists");
ok($result->md5sum, "sai md5 exists");
ok(-s $result->log_file, "log file exists");
my $md5_1 = $result->md5sum;

######################################################################
# Check that making a duplicate fails, but get_or_create works
my $duplicate = $result_class->create(%params);
ok(!$duplicate, "creating duplicate result fails as expected");
my $fetched = $result_class->get_or_create(%params, users => $result_users);
ok($fetched, "fetched object with get_or_create");
is($result->id, $fetched->id, "get_or_create returned the right object");

######################################################################
# Create 2nd object
$params{input_pass} = 2;
$result = $result_class->create(%params);
ok($result, "created result (2nd end)");
$result->add_user(label => 'uses', user => $parent_result); #normally the outer alignment would do this upon getting back the intermediate result
push(@result_ids, $result->id);

ok($result->users, "found parent in software result users");
$parent_in_users = grep {$_->user_id == $parent_result->id and $_->user_class_name eq $parent_result->class} $result->users;
ok($parent_in_users, "found parent in list of users");

$dir = $result->output_dir;
ok(-s $result->sai_file, "sai file exists");
ok($result->md5sum, "sai md5 exists");
ok(-s $result->log_file, "log file exists");
my $md5_2 = $result->md5sum;

ok($md5_1 ne $md5_2, "md5sums differ as expected");
$fetched = $result_class->get_or_create(%params, users => $result_users);
eval { $fetched->delete; };
ok(($@ and $fetched->id), "direct deletion of non-orphaned IntermediateAlignmentResult forbidden");

map { $_->active(0) } Genome::SoftwareResult::User->get(
    software_result_id => \@result_ids,
    label => ['sponsor', 'created', 'shortcut'],
);

$parent_result->delete();

my @objs = $result_class->get(\@result_ids);
$DB::single = 1;
ok(!@objs, "deleting parent result deleted children as well when no other users");

done_testing();

# Helper functions
sub generate_fake_instrument_data {
    my $sample = Genome::Sample->create(name => 'test_sample_name');
    ok($sample, 'create sample') or die;
    my $library = Genome::Library->create(name => $sample->name.'-lib1', sample => $sample);
    ok($library, 'create library');

    my $fastq_directory = $ENV{GENOME_TEST_INPUTS} . '/Genome-InstrumentData-Align-Maq/test_sample_name';
    my $instrument_data = Genome::InstrumentData::Solexa->create(
        library => $library,
        flow_cell_id => '12345',
        lane => '1',
        median_insert_size => '22',
        run_name => '110101_TEST',
        subset_name => 4,
        run_type => 'Paired',
        gerald_directory => $fastq_directory,
        bam_path => $ENV{GENOME_TEST_INPUTS} . '/Genome-InstrumentData-IntermediateAlignmentResult-Bwa/input.bam'
    );
    ok($instrument_data, 'create instrument data: '. $instrument_data->id);
    ok($instrument_data->is_paired_end, 'instrument data is paired end');

    return $instrument_data;
}

sub generate_fake_alignment_result {
    my ($instrument_data) = @_;

    my $class = 'Genome::InstrumentData::AlignmentResult::Bwa';
    my $alignment_result = Genome::InstrumentData::AlignmentResult::Bwa->__define__(
                 id => -8765432,
                 output_dir => '/tmp',
                 instrument_data_id => $instrument_data->id,
                 subclass_name => $class,
                 module_version => '12345',
                 aligner_name => $aligner_name,
                 aligner_version => $aligner_version,
    );
    $alignment_result->lookup_hash($alignment_result->calculate_lookup_hash());
    ok($alignment_result, 'created fake alignment result');

    return $alignment_result;
}
