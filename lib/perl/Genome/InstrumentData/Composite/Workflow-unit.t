#!/usr/bin/env genome-perl

use strict;
use warnings;

BEGIN {
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{NO_LSF} = 1;
}

use above 'Genome';
use Test::More;
use Genome::Utility::Test;
use Genome::Test::Factory::InstrumentData::Solexa;

my $pkg = 'Genome::InstrumentData::Composite::Workflow';

use_ok($pkg);

my $idata = Genome::Test::Factory::InstrumentData::Solexa->setup_object(
    flow_cell_id => '12345ABXY',
    lane => '1',
    subset_name => '1',
    run_name => 'workflow-unit-test',
    id => '-42',
);

my $ref = Genome::Model::Build::ReferenceSequence->get_by_name('GRCh37-lite-build37');

my $inputs = {
    inst => [$idata],
    ref => $ref,
    force_fragment => 0,
};

my $log_directory = Genome::Sys->create_temp_directory;
my $base_strategy = 'inst aligned to ref using bwamem-stream 0.7.10 [-t 8]';

# explicitly test that bedtools version is defined for api v6
subtest "bedtools versions api v6" => sub {
    my $strategy = "$base_strategy api v6";
    my ($wf, $inputs) = workflow_and_inputs_for_strategy($strategy);
    ok(exists $inputs->{m_bedtools_version}, "m_bedtools_version input exists");
    my $bt_version = $inputs->{m_bedtools_version};
    ok($bt_version, "bedtools version is defined for api v6");
    my $bedtools_path = Genome::Model::Tools::BedTools->path_for_bedtools_version($bt_version);
    # Don't care if it actually exists, only that the bedtools module returns something.
    ok($bedtools_path, "got a path for bedtools version $bt_version from api v6.");
};

for my $ver ($pkg->available_api_versions) {
    subtest "check program versions api $ver" => sub {
        my $strategy = "$base_strategy api $ver";
        my ($wf, $inputs) = workflow_and_inputs_for_strategy($strategy);

        my $samtools_version = $inputs->{m_samtools_version};
        ok($samtools_version, "got samtools version");
        my $samtools_path = Genome::Model::Tools::Sam->path_for_samtools_version($samtools_version);
        ok($samtools_path, "got path for samtools version $samtools_version");

        my $picard_version = $inputs->{m_picard_version};
        ok($picard_version, "got picard version");
        my $picard_path = Genome::Model::Tools::Picard->path_for_picard_version($picard_version);
        ok($picard_path, "got path for picard version $picard_version");

        # bedtools version may or may not be defined
        my $bedtools_version = $inputs->{m_bedtools_version};
        if (defined $bedtools_version) {
            ok($bedtools_version, "got bedtools version");
            my $bedtools_path = Genome::Model::Tools::BedTools->path_for_bedtools_version($bedtools_version);
            ok($bedtools_path, "got path for bedtools version $bedtools_version");
        }

        subtest "verify workflow" => sub {
            my @ops = $wf->operations;
            ok(@ops, "got some workflow operations");

            my @links = $wf->links;
            ok(@links, "got some workflow links");

            my $id = $idata->id;
            my @dispatch_ops = grep {$_->name eq "Alignment Dispatcher for $id"} @ops;
            is(scalar @dispatch_ops, 1, "Found main dispatch workflow operation");
            my $dispatch_op = $dispatch_ops[0];
            isa_ok($dispatch_op, "Workflow::Model", "Alignment dispatcher operation");

            my @bedtools_links = grep {
                $_->left_workflow_operation_id eq $wf->input_connector->id &&
                $_->right_workflow_operation_id eq $dispatch_op->id &&
                $_->left_property =~ /bedtools_version/
                } @links;
            is(scalar @bedtools_links, 1, "found bedtools link to main dispatch op");

            @bedtools_links = grep {
                $_->left_property =~ /bedtools_version/
                } $dispatch_op->links;

            is(scalar @bedtools_links, 1, "found bedtools link from main dispatch op");
            like($bedtools_links[0]->right_operation->workflow_operationtype_id, qr/AlignReads/,
                "bedtools version passed to AlignReads");
        };
    };
}

done_testing();

sub workflow_and_inputs_for_strategy {
    my $strategy = shift;
    my $obj = $pkg->create(
            inputs => $inputs,
            strategy => $strategy,
            log_directory => $log_directory,
            );

    my $tree = $obj->_process_strategy($strategy);
    ok($tree, "strategy parsed");

    my ($wf, $wf_inputs) = $obj->_generate_workflow($tree);
    isa_ok($wf, "Workflow::Model", "workflow model");
    isa_ok($wf_inputs, "ARRAY", "workflow inputs");

    my %inputs = @$wf_inputs;
    return ($wf, \%inputs);
}
