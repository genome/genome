#!/usr/bin/env genome-perl
use strict;
use warnings;

BEGIN {
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
    $ENV{UR_DBI_NO_COMMIT} = 1;
};

use above "Genome";
use Data::Dumper;
use Test::More tests => 5;

class Foo::Bar {
    has => {
        cake => { is => 'Text' },
    },
};

class Genome::Model::Command::Test {
    is => 'Command::V2',
    has => [
        bar => { is => 'Foo::Bar' },
        bars => { is => 'Foo::Bar', is_many => 1 },
        thing => { is => 'Text', default_value => 'thingy' },
    ]
};

my $cmd = Genome::Model::Command::Test->create();
$cmd->queue_error_messages(1);
$cmd->dump_error_messages(0);
$cmd->dump_status_messages(0);

# bar is already the right class, it should not be resolved. bars should, however.
my $bar = Foo::Bar->create(cake => "a lie");
my $params = { bar => $bar, bars => [2,3,4], thing => 'stuff' };
my $expected = [ { name => 'bars', class => 'Foo::Bar', value => [2,3,4] } ];
my @resolve = $cmd->_params_to_resolve($params);
is_deeply(\@resolve, $expected, "_params_to_resolve doesn't try to resolve unneccessarily");


# neither bar nor bars are a Foo::Bar, they should both be resolved
$params = { bar => 'something', bars => [2,3,4], thing => 'stuff' };
$expected = [
    { name => 'bar', class => 'Foo::Bar', value => ['something'] },
    { name => 'bars', class => 'Foo::Bar', value => [2,3,4] },
];
@resolve = $cmd->_params_to_resolve($params);
is_deeply(\@resolve, $expected, "_params_to_resolve works");


# bar is not a scalar or arrayref, it should be skipped and warned about
$params = { bar => { bad => 'ness' }, bars => [2,3,4] };
$expected = [ { name => 'bars', class => 'Foo::Bar', value => [2,3,4] } ];
@resolve = $cmd->_params_to_resolve($params);
is_deeply(\@resolve, $expected, "_params_to_resolve warns and skips unknown classes as values");

my @errs = $cmd->error_messages();
is(scalar(@errs), 1, "error message produced");
like($errs[0], qr/no handler.*'bar'.*HASH/, "error message looks correct");

done_testing();
