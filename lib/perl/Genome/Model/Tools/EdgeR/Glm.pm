package Genome::Model::Tools::EdgeR::Glm;

use Genome;
use Carp qw/confess/;
use List::MoreUtils qw/uniq/;

use strict;
use warnings;

my $R_SCRIPT = __FILE__ . ".R";

class Genome::Model::Tools::EdgeR::Glm {
    is => "Genome::Model::Tools::EdgeR::Base",
    has => [
        subjects => {
            is => "Text",
            doc => "Comma separated list of subject IDs corresponding to " .
                "the subjects for each column in counts_file (e.g, s1,s2,...)",
        }
    ],
    doc => "Run edgeR's GLM analysis on the given expression counts",
};

sub help_synopsis {
    return <<EOS

gmt edge-r glm --counts-file counts.txt --groups A,A,B,B,B --subjects s1,s2,s1,s2,s3 --output-file out.txt

gmt edge-r glm --counts-file counts.txt --groups normal,tumor,tumor --subjects s1,s1,s2 --output-file out.txt

EOS
}

sub help_detail {
    return <<EOS

Detect structures (genes/transcripts) with significantly different expression
levels across groups (e.g., tumor, normal), adjusting for any differences
between patients, using edgeR. It is important to note that at least one of the
groups must contain more than one member (replication).

The input "counts" file should be a headered tab delimited file containing a
header where the first column is the name of an structure and the subsequent
columns are per-sample expression counts generated by a program like
htseq-count. A brief example:

    Gene    S1N     S2N     S1T     S2T
    GENE0   13      12      52      53
    GENE1   13      14      12      13
    GENE2   15      13      14      15
    GENE3   14      13      14      13
    ...

The groups parameter should be a comma separated list of condition ids to
associate with each of the input samples. In the example above, this might be
something like "normal,normal,tumor,tumor" or "N,N,T,T".

The subjects parameter should be a comma separated list of subject ids to
associate with each of the input samples. In the example above, this might be
something like "sample1,sample2,sample1,sample2" or "S1,S2,S1,S2".

The output file consists of 6 columns (one row per input object):

    1) the object name
    2) log2-fold change of expression between conditions being tested (logFC)
    3) average log2-counts per million, the average taken over all libraries in the input (logCPM)
    4) the likelihood ratio statistics (LR)
    5) the exact (uncorrected) p-value for differential expression
    6) classification result (-1 = down, 0 = no DE, 1 = up).

Example output:

            logFC               logCPM              LR                  PValue              test.result
    GENE0   2.03096474766892    18.8147545545492    51.3199686034951    7.8473335851111e-13 1
    GENE1   -0.142929505866188  17.6191570481935    0.129882595682682   0.718553798773428   0
    GENE3   -0.026827032144403  17.6658365813296    0.00476315215669459 0.94497720721642    0
    GENE2   0.0218210997015531  17.7331941351027    0.0033211089088292  0.954044099165337   0
    ...

EOS
}

sub construct_r_command {
    my $self = shift;

    my $cmd = sprintf("Rscript %s --input-file %s --groups '%s' --subjects '%s' --output-file %s --pvalue %f",
            $R_SCRIPT,
            $self->counts_file,
            $self->groups,
            $self->subjects,
            $self->output_file,
            $self->p_value
            );

    return $cmd;
}

sub _list_validator_subroutines {
    return (
        "_replication_in_one_group",
        "_more_than_one_group",
        "_replication_for_each_subject",
        "_more_than_one_subject",
        "_same_length_of_groups_and_subjects",
        "_at_least_one_for_each_subject_for_each_group"
    );
}

sub _replication_for_each_subject {
    my $self = shift;

    my @subjects = split(",", $self->subjects);
    my %subject_sizes;
    for my $s (@subjects) {
        ++$subject_sizes{$s};
    }

    while( my ($key, $value) = each %subject_sizes ) {
        unless ($value > 1) {
            confess "Each subject must be used more than once";
        }
    }

    return 1;
}

sub _more_than_one_subject {
    my $self = shift;

    my @subjects = split(",", $self->subjects);
    my %subject_sizes;
    for my $s (@subjects) {
        ++$subject_sizes{$s};
    }

    unless (scalar(keys(%subject_sizes)) > 1) {
        confess "There needs to be more than one subject\n";
    }

    return 1;
}

sub _same_length_of_groups_and_subjects {
    my $self = shift;

    my @groups = split(",", $self->groups);
    my @subjects = split(",", $self->subjects);

    unless (scalar(@groups) == scalar(@subjects)) {
        confess "There needs to be the same number of entries for groups and subjects";
    }

    return 1;
}

sub _at_least_one_for_each_subject_for_each_group {
    my $self = shift;

    my @groups = split(",", $self->groups);
    my @subjects = split(",", $self->subjects);

    my %subject_group_sizes;

    for my $index (0..$#groups) {
        ++$subject_group_sizes{$subjects[$index]}{$groups[$index]};
    }
    $DB::single=1;

    my @unique_groups = uniq @groups;
    my @unique_subjects = uniq @subjects;

    for my $g (@unique_groups) {
        for my $s (@unique_subjects) {
            unless (defined($subject_group_sizes{$s}{$g})) {
                confess "Each subject needs to have at least one entry for each group";
            }
        }
    }

    return 1;
}

1;
