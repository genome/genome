use strict; use warnings;

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
}

use above "Genome";
use Data::Dumper;
use Test::More tests => 34;
use_ok('Genome::Model::Build::ImportedReferenceSequence');

use Genome::Test::Factory::AnalysisProject;

# create a test annotation build and a few reference sequence builds to test compatibility with
my @species_names = ('human', 'mouse');
my @versions = (1, 2, 3);
my $data_dir = File::Temp::tempdir('ImportedAnnotationTest-XXXXX', CLEANUP => 1, TMPDIR => 1);

my %samples;
for my $sn (@species_names) {
    my $t = Genome::Taxon->__define__(name => $sn);
    my $p = Genome::Individual->create(name => "test-$sn-patient", common_name => 'testpatient', taxon => $t);
    my $s = Genome::Sample->create(name => "test-$sn-patient", common_name => 'tumor', source => $p);
    ok($s, 'created sample');
    $samples{$sn} = $s;
}
my %rbuilds = create_reference_builds(\@species_names, \@versions);

# 1 -> 2
$rbuilds{'human'}[1]->derived_from($rbuilds{'human'}[0]);
$rbuilds{'human'}[1]->coordinates_from($rbuilds{'human'}[1]->derived_from_root);
ok(!$rbuilds{'human'}[0]->is_compatible_with(), 'build is not compatible with null');
ok($rbuilds{'human'}[0]->is_derived_from($rbuilds{'human'}[0]), 'build is derived from itself');
ok($rbuilds{'human'}[0]->is_compatible_with($rbuilds{'human'}[0]), 'build is compatible with itself');
ok($rbuilds{'human'}[0]->is_derived_from($rbuilds{'human'}[0]), 'build w/no parent gets coordinates_from itself');
ok($rbuilds{'human'}[1]->is_derived_from($rbuilds{'human'}[0]), 'build is derived from its parent');
ok($rbuilds{'human'}[1]->is_derived_from($rbuilds{'human'}[0]), 'build is compatible with its parent');
is($rbuilds{'human'}[1]->derived_from_root(), $rbuilds{'human'}[0], 'build w/1 lvl of parent gets coordinates_from parent');
ok(!$rbuilds{'human'}[0]->is_derived_from($rbuilds{'human'}[1]), 'build is not derived from its descendant');
ok($rbuilds{'human'}[0]->is_compatible_with($rbuilds{'human'}[1]), 'build is compatible with its child');

# 1 -> 2 -> 3
$rbuilds{'human'}[2]->derived_from($rbuilds{'human'}[1]);
$rbuilds{'human'}[2]->coordinates_from($rbuilds{'human'}[2]->derived_from_root);
ok($rbuilds{'human'}[2]->is_derived_from($rbuilds{'human'}[0]), 'build is derived from grandparent');
ok($rbuilds{'human'}[2]->is_compatible_with($rbuilds{'human'}[0]), 'build is compatible with its grandparent');
ok($rbuilds{'human'}[0]->is_compatible_with($rbuilds{'human'}[2]), 'build is compatible with its grandchild');
is($rbuilds{'human'}[2]->derived_from_root(), $rbuilds{'human'}[0], 'build w/2 lvl of parent gets coordinates_from grandparent');

# attempt to derive from another model's build
$DB::single = 1;
my @errs =$rbuilds{'human'}[0]->validate_for_start() ;
ok(!@errs, "no errors so far...")
    or die "Unexpected errors:\n\t" . join("\n\t", map{$_->__display_name__} @errs);

#allowing derived_from builds from other models
#$rbuilds{'human'}[0]->derived_from($rbuilds{'mouse'}[0]);
#@errs = $rbuilds{'human'}[0]->validate_for_start();
#ok(@errs, "deriving from another model's build is an error");
#ok($errs[0]->type, 'error type is correct');
#is($errs[0]->{properties}->[0], 'derived_from', 'error references derived_from property');

# attempt to derive from self
$DB::single = 1;
@errs = $rbuilds{'human'}[1]->validate_for_start();
ok(!@errs, "no errors so far...")
    or die "Unexpected errors:\n\t" . join("\n\t", map{$_->__display_name__} @errs);
$rbuilds{'human'}[1]->derived_from($rbuilds{'human'}[1]);
@errs = $rbuilds{'human'}[1]->validate_for_start();
ok(@errs, "deriving from self is an error");
ok($errs[0]->type, 'error type is correct');
is($errs[0]->{properties}->[0], 'derived_from', 'error references derived_from property');

# set up circular link
$rbuilds{'human'}[0]->derived_from($rbuilds{'human'}[1]);
$rbuilds{'human'}[1]->derived_from($rbuilds{'human'}[0]);
@errs = $rbuilds{'human'}[1]->validate_for_start();
ok(@errs, "circular links are reported in validate_for_start()");
is($errs[0]->{properties}->[0], 'derived_from', 'error references derived_from property');
like($errs[0]->{desc}, '/Circular/', 'error mentions "circular"');
eval { $rbuilds{'human'}[1]->is_derived_from($rbuilds{'human'}[3]); };
ok($@, 'circular links are detected in is_derived_from');
eval { $rbuilds{'human'}[1]->derived_from_root(); };
ok($@, 'circular links are detected in coordinates from');

done_testing();

sub create_reference_builds {
    my ($species_names, $versions) = @_;
    my %rbuilds;
    my $ref_pp = Genome::ProcessingProfile::ImportedReferenceSequence->create(name => 'test_ref_pp');
    for my $sn (@$species_names) {
        $rbuilds{$sn} = [];

        my $ref_model = Genome::Model::ImportedReferenceSequence->create(
            name                => "test_ref_sequence_$sn",
            processing_profile  => $ref_pp,
            subject_class_name  => ref($samples{$sn}),
            subject_id          => $samples{$sn}->id,
        );
        ok($ref_model, "created reference sequence model ($sn)");

        my $anp = Genome::Test::Factory::AnalysisProject->setup_object();
        $anp->add_model_bridge(model_id => $ref_model->id);

        for my $v (@$versions) {
            my $rs = Genome::Model::Build::ImportedReferenceSequence->create(
                name            => "ref_sequence_${sn}_$v",
                model           => $ref_model,
                fasta_file      => 'nofile',
                data_directory  => $data_dir,
                version         => $v,
                );
            ok($rs, "created ref seq build $sn $v");
            push(@{$rbuilds{$sn}}, $rs);
        }
    }
    return %rbuilds;
}
