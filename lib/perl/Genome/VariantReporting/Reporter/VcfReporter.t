#!/usr/bin/env genome-perl

BEGIN { 
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
}

use strict;
use warnings;

use above "Genome";
use Test::More;
use Genome::Utility::Test qw(compare_ok);
use Set::Scalar;
use List::MoreUtils qw(each_array);
use Genome::File::Vcf::Entry;

my $pkg = 'Genome::VariantReporting::Reporter::VcfReporter';
use_ok($pkg);

my $factory = Genome::VariantReporting::Framework::Factory->create();
isa_ok($factory->get_class('reporters', $pkg->name), $pkg);

my $indel_filter_pkg = 'Genome::VariantReporting::Generic::ContainsTagFilter';
use_ok($indel_filter_pkg);

my $ft_filter_pkg = 'Genome::VariantReporting::Generic::FTKeepFilter';
use_ok($ft_filter_pkg);

my $indel_filter = $indel_filter_pkg->create(info_tag => 'ON_TARGET');
ok($indel_filter->isa($indel_filter_pkg), 'Filter created successfully');

my $ft_filter = $ft_filter_pkg->create(sample_name => 'S1');
ok($ft_filter->isa($ft_filter_pkg), 'Filter created successfully');

my $data_dir = __FILE__.".d";

subtest 'report subroutine' => sub {
    my $reporter = get_test_reporter();
    my $output_dir = Genome::Sys->create_temp_directory();
    $reporter->initialize($output_dir);

    $reporter->report(interpretations());
    $reporter->finalize();
    compare_ok(
        File::Spec->join($output_dir, 'vcf'),
        File::Spec->join($data_dir, 'expected_after_report.vcf'),
        'Output vcf as expected'
    );
};

subtest 'soft_filters subroutine' => sub {
    my $reporter = get_test_reporter();

    my $expected_filters = Set::Scalar->new($indel_filter, $ft_filter);
    my $actual_filters = Set::Scalar->new($reporter->soft_filters);
    ok($actual_filters->is_equal($expected_filters), 'Filter interpreter list as expected');
};

subtest 'add_header_for_main_filter subroutine' => sub {
    my $reporter = get_test_reporter();

    my $entry = create_entry();
    my $header = $entry->{'header'};

    $reporter->add_header_for_main_filter($header);
    ok($header->info_types->{ALLFILTERSPASS}, "Main filter header ALLFILTERSPASS was added successfully");
};

subtest 'add_headers_for_soft_filters subroutine' => sub {
    my $reporter = get_test_reporter();

    my $entry = create_entry();
    my $header = $entry->{'header'};

    $reporter->add_headers_for_soft_filters($header);
    my $expected_filter_ids = Set::Scalar->new(keys %{$header->filters});
    for my $filter ($reporter->soft_filters) {
        ok($expected_filter_ids->contains($filter->vcf_id), sprintf('Header containts FILTER tag for %s interpreter: %s', $filter->name, $filter->vcf_id));
    }
};

subtest 'print_vcf_header subroutine' => sub {
    my $reporter = get_test_reporter();

    my $entry = create_entry();
    my $header = $entry->{'header'};

    my $output_dir = Genome::Sys->create_temp_directory();
    $reporter->initialize($output_dir);
    $reporter->header($header);

    $reporter->print_vcf_header;
    $reporter->finalize();

    compare_ok(
        File::Spec->join($output_dir, 'vcf'),
        File::Spec->join($data_dir, 'expected_after_print_vcf_header.vcf'),
        'Output vcf as expected'
    );
};

subtest 'process_header subroutine' => sub {
    my $reporter = get_test_reporter();

    my $output_dir = Genome::Sys->create_temp_directory();
    $reporter->initialize($output_dir);

    my $entry = create_entry();
    $reporter->process_header($entry->{'header'});
    $reporter->finalize();

    compare_ok(
        File::Spec->join($output_dir, 'vcf'),
        File::Spec->join($data_dir, 'expected_after_process_header.vcf'),
        'Output vcf as expected'
    );
};

subtest 'all_filters_passed_for_allele subroutine' => sub {
    my $reporter = get_test_reporter();

    my @alleles = qw( C AT T );
    my @results = @{expected_final_results()};

    my $it = each_array( @alleles, @results );
    while ( my ($allele, $result) = $it->() ) {
        is(
            $reporter->all_filters_passed_for_allele(interpretations(), $allele),
            $result,
            "Result for allele ($allele) calculated correctly: ($result)"
        );
    }
};

subtest 'determine_final_results subroutine' => sub {
    my $reporter = get_test_reporter();

    my @final_results = $reporter->determine_final_results(interpretations(), create_entry());
    is_deeply(\@final_results, expected_final_results(), "Final filter results as expected");
};

subtest 'add_final_results subroutine' => sub {
    my $reporter = get_test_reporter();

    my $entry = create_entry();

    Genome::VariantReporting::Reporter::VcfReporter::add_final_results($entry, @{expected_final_results()});
    is($entry->info('ALLFILTERSPASS'), '1,0,0', 'ALLFILTERPASS INFO field added correctly');
};

subtest '_process_entry subroutine' => sub {
    my $reporter = get_test_reporter();

    my $output_dir = Genome::Sys->create_temp_directory();
    $reporter->initialize($output_dir);

    my $entry = create_entry();
    $reporter->header($entry->{'header'});
    $reporter->print_vcf_header;

    $reporter->_process_entry(create_entry(), interpretations());
    $reporter->finalize();

    compare_ok(
        File::Spec->join($output_dir, 'vcf'),
        File::Spec->join($data_dir, 'expected_after_process_entry.vcf'),
        'Output vcf as expected'
    );
};

done_testing;

sub get_test_reporter {
    my $reporter = Genome::VariantReporting::Reporter::VcfReporter->create(file_name => 'vcf');
    ok($reporter, "Reporter created successfully");

    $reporter->add_interpreter_object($indel_filter);
    $reporter->add_interpreter_object($ft_filter);
    return $reporter;
}

sub interpretations {
    my $entry = create_entry();
    return {
        $indel_filter->name => {
            C  => { filter_status => 1, },
            AT => { filter_status => 1, },
            T  => { filter_status => 0, },
        },
        $ft_filter->name => {
            C  => { filter_status => 1, },
            AT => { filter_status => 0, },
            T  => { filter_status => 0, },
        },
        'vcf-entry' => {
            C  => { vcf_entry => $entry, },
            AT => { vcf_entry => $entry, },
            T  => { vcf_entry => $entry, },
        }
    };
}

sub expected_final_results {
    return [1,0,0];
}

sub create_vcf_header {
    my $header_txt = <<EOS;
##fileformat=VCFv4.1
#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	S1	S2	S3	S4	S5
EOS
    my @lines = split("\n", $header_txt);
    my $header = Genome::File::Vcf::Header->create(lines => \@lines);
    return $header
}

sub create_entry {
    my @fields = (
        '1',            # CHROM
        10,             # POS
        '.',            # ID
        'A',           # REF
        'C,AT,T',     # ALT
        '.',            # QUAL
        '.',         # FILTER
        '.',  # INFO
        'GT:DP',     # FORMAT
        "1/1:12",   # S1
        "0/1:12",   # S2
        "1/2:12",   # S3
        "0/0:12",   # S4
        '.'         # S5
    );

    my $entry_txt = join("\t", @fields);
    my $entry = Genome::File::Vcf::Entry->new(create_vcf_header(), $entry_txt);
    return $entry;
}
