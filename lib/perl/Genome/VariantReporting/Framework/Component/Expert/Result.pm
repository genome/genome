package Genome::VariantReporting::Framework::Component::Expert::Result;

use strict;
use warnings FATAL => 'all';
use Genome;

class Genome::VariantReporting::Framework::Component::Expert::Result {
    is_abstract => 1,
    is => 'Genome::SoftwareResult::StageableSimple',
    has_input => [
        input_vcf_lookup => {
            is => 'Text',
        },
    ],
    has_param => [
        variant_type => {
            is => 'Text',
            valid_values => ['snvs', 'indels'],
        },
    ],
    has_transient_optional => [
        input_vcf => {
            is => 'Path',
        },
    ],
};

sub output_filename {
    die "Abstract";
}

sub output_file_path {
    my $self = shift;
    return File::Spec->join($self->output_dir, $self->output_filename);
}

sub transient_names {
    my $self = shift;

    return map {$_->property_name} $self->__meta__->properties(is_transient => 1);
}

sub param_names {
    my $self = shift;
    return ($self->is_many_param_names, $self->is_not_many_param_names);
}

sub is_many_param_names {
    my $self = shift;

    return map {$_->property_name} $self->__meta__->properties(is_many => 1, is_param => 1);
}

sub is_not_many_param_names {
    my $self = shift;

    my @names = map {$_->property_name} $self->__meta__->properties(is_many => 0, is_param => 1);
    my $names = Set::Scalar->new(@names);
    for my $name ($self->is_many_param_names, $self->is_many_input_names, $self->is_many_metric_names) {
        $names->delete($name . "_count");
        $names->delete($name . "_md5");
    }
    return $names->members();
}

sub param_hash {
    my $self = shift;

    my %hash;
    for my $param_name ($self->is_many_param_names) {
        $hash{$param_name} = [$self->$param_name];
    }
    for my $param_name ($self->is_not_many_param_names) {
        $hash{$param_name} = $self->$param_name;
    }
    return %hash;
}

sub metric_names {
    my $self = shift;

    return ($self->is_not_many_metric_names, $self->is_many_metric_names);
}

sub is_not_many_metric_names {
    my $self = shift;

    return map {$_->property_name} $self->__meta__->properties(is_many => 0, is_metric => 1);
}

sub is_many_metric_names {
    my $self = shift;

    return map {$_->property_name} $self->__meta__->properties(is_many => 1, is_metric => 1);
}

sub input_names {
    my $self = shift;
    return ($self->is_many_input_names, $self->is_not_many_input_names);
}

sub is_many_input_names {
    my $self = shift;

    return map {$_->property_name} $self->__meta__->properties(is_many => 1, is_input => 1);
}

sub is_not_many_input_names {
    my $self = shift;

    return map {$_->property_name} $self->__meta__->properties(is_many => 0, is_input => 1);
}

sub input_hash {
    my $self = shift;

    my %hash;
    for my $input_name ($self->is_many_input_names) {
        $hash{$input_name} = [$self->$input_name];
    }
    for my $input_name ($self->is_not_many_input_names) {
        $hash{$input_name} = $self->$input_name;
    }
    return %hash;
}
