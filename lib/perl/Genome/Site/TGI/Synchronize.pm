package Genome::Site::TGI::Synchronize;

use strict;
use warnings;
use Genome;

class Genome::Site::TGI::Synchronize {
    is => 'Genome::Command::Base',
    has_optional => [
        report_file => {
            is => 'FilePath',
            doc => 'If provided, extra information is recorded in this file'
        },
        detailed_report => {
            is => 'Boolean',
            default => 0,
            doc => 'If set, a detailed report is printed that lists all the objects that were copied/missing',
        },
        _report => {
            is_transient => 1,
            doc => 'Contains hashref to report generated by the execution of this tool',
        },
    ],
    doc => 'This command copies new objects in the old LIMS based classes to the new classes that use the MG schema. ' .
        'It then removes all non-imported instrument data that are no longer represented in the LIMS based classes', 
};

sub execute {
    my $self = shift; 

    my $update = Genome::Site::TGI::Synchronize::UpdateApipeClasses->create();
    die "Failed to create update apipe classes!" if not $update;
    my $rv = eval{ $update->execute; };
    if (not $rv) {
        die $self->error_message("$@\nFailed to execute update apipe classes!");
    }

    my $expunge = eval { Genome::Site::TGI::Synchronize::Expunge->execute(report => $update->_report) };
    unless ($expunge) {
        $self->error_message("Failed to Expunge: $@");
        die $self->error_message;
    }
    $self->_report($expunge->report);

    my $report_string = $self->generate_report;
    print $report_string;
    $self->write_report_file($report_string) if defined $self->report_file;

    return 1;
}

# Generates a summary report with number of objects missing/copied per type
sub generate_report {
    my $self = shift;
    return $self->generate_detailed_report if $self->detailed_report;

    my %report = %{$self->_report};
    my $string;
    for my $type (sort keys %report) {
        $string .= "Type $type";
        for my $operation (qw/ copied missing deleted /) {
            my $num = 0;
            if (exists $report{$type}{$operation}) {
                $num = scalar @{$report{$type}{$operation}};
            }
            $string .= (', ' . (ucfirst $operation) . " $num");
        }
        $string .= "\n";
    }
    return $string;
}

# Generates a string representation of the report hash, which details the objects that were copied from the
# old tables to the new and also lists those IDs that exist in the new tables but not the old.
sub generate_detailed_report {
    my $self = shift;
    my %report = %{$self->_report};

    my $string;
    for my $type (sort keys %report) {
        $string .= "*** Type $type ***\n";
        for my $operation (qw/ copied missing deleted /) {
            next unless exists $report{$type}{$operation};
            $string .= ucfirst $operation . "\n";
            $string .= join("\n", @{$report{$type}{$operation}}) . "\n";
        }
    }
    
    return $string;
}

# Writes report string to a file
sub write_report_file {
    my ($self, $report_string) = @_;
    my $fh = IO::File->new($self->report_file, 'w');
    if ($fh) {
        $fh->print($report_string);
    }
    else {
        $self->warning_message("Could not get file handle for " . $self->report_file . ", not writing report");
    }
    return 1;
}

1;
